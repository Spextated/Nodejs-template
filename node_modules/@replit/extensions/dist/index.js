var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/types/fs.ts
var FsNodeType = /* @__PURE__ */ ((FsNodeType2) => {
  FsNodeType2["File"] = "FILE";
  FsNodeType2["Directory"] = "DIRECTORY";
  return FsNodeType2;
})(FsNodeType || {});
var ChangeEventType = /* @__PURE__ */ ((ChangeEventType2) => {
  ChangeEventType2["Create"] = "CREATE";
  ChangeEventType2["Move"] = "MOVE";
  ChangeEventType2["Delete"] = "DELETE";
  ChangeEventType2["Modify"] = "MODIFY";
  return ChangeEventType2;
})(ChangeEventType || {});

// src/types/themes.ts
var ColorScheme = /* @__PURE__ */ ((ColorScheme2) => {
  ColorScheme2["Light"] = "light";
  ColorScheme2["Dark"] = "dark";
  return ColorScheme2;
})(ColorScheme || {});

// src/types/data.ts
var UserSocialType = /* @__PURE__ */ ((UserSocialType2) => {
  UserSocialType2["twitter"] = "twitter";
  UserSocialType2["github"] = "github";
  UserSocialType2["linkedin"] = "linkedin";
  UserSocialType2["website"] = "website";
  UserSocialType2["youtube"] = "youtube";
  UserSocialType2["twitch"] = "twitch";
  UserSocialType2["facebook"] = "facebook";
  UserSocialType2["discord"] = "discord";
  return UserSocialType2;
})(UserSocialType || {});

// src/types/index.ts
var HandshakeStatus = /* @__PURE__ */ ((HandshakeStatus2) => {
  HandshakeStatus2["Ready"] = "ready";
  HandshakeStatus2["Error"] = "error";
  HandshakeStatus2["Loading"] = "loading";
  return HandshakeStatus2;
})(HandshakeStatus || {});

// src/util/comlink.ts
import * as Comlink from "comlink";
var extensionPort = (() => typeof window !== "undefined" ? Comlink.wrap(
  Comlink.windowEndpoint(self.parent, self, "*")
) : null)();
var proxy2 = Comlink.proxy;

// src/util/handshake.ts
var handshakeStatus = "loading" /* Loading */;
var setHandshakeStatus = (status) => {
  handshakeStatus = status;
};
var getHandshakeStatus = () => handshakeStatus;

// src/api/fs/index.ts
var fs_exports = {};
__export(fs_exports, {
  copyFile: () => copyFile,
  createDir: () => createDir,
  deleteDir: () => deleteDir,
  deleteFile: () => deleteFile,
  move: () => move,
  readDir: () => readDir,
  readFile: () => readFile,
  watchDir: () => watchDir,
  watchFile: () => watchFile,
  watchTextFile: () => watchTextFile,
  writeFile: () => writeFile
});

// src/api/fs/watching.ts
import { ChangeSet, Text } from "@codemirror/state";
function changeSetToSimpleTextChange(changes) {
  const simpleChanges = [];
  changes.iterChanges((fromA, toA, _fromB, _toB, text) => {
    const change = { from: fromA };
    if (toA > fromA) {
      change.to = toA;
    }
    if (text.length) {
      change.insert = text.sliceString(0);
    }
    simpleChanges.push(change);
  });
  return simpleChanges;
}
var TextFileWatcher = class {
  constructor(path, listeners) {
    this.path = path;
    this.listeners = listeners;
    this.state = null;
    this.isDisposed = false;
    this.dispose = () => {
      this.isDisposed = true;
    };
    if (!extensionPort) {
      throw new Error("Expected extensionPort");
    }
    extensionPort.watchTextFile(
      this.path,
      proxy2({
        onReady: this.handleReady.bind(this),
        // wrongly typed at extensionPort
        onChange: this.handleChange.bind(this),
        onMoveOrDelete: (event) => {
          listeners.onMoveOrDelete(event);
        },
        onError: (error2) => {
          listeners.onError(error2);
        }
      })
    ).then((portDispose) => {
      if (this.isDisposed) {
        portDispose();
        return;
      }
      this.dispose = () => {
        this.isDisposed = true;
        portDispose();
      };
    });
  }
  /*
   * TODO: what do we do with out of order messages, postMessage has no guarantees of order
   * TODO: we need versioning to guarantee correctness. Related to above, using async/await doesn't guarantee that our change got applied before the next incoming change and vice versa
   */
  state;
  isDisposed;
  dispose;
  writeChange(changes) {
    if (this.isDisposed) {
      throw new Error("Wrote change on a disposed TextFileWatcher");
    }
    if (!this.state) {
      throw new Error("Tried to write changes before ready");
    }
    const changeSet = ChangeSet.of(changes, this.state.localText.length);
    this.state.localText = changeSet.apply(this.state.localText);
    this.enqueueChangeSet(changeSet);
  }
  getLatestContent() {
    if (this.isDisposed) {
      throw new Error("Cannot get content of a disposed TextFileWatcher");
    }
    if (!this.state) {
      throw new Error("Called getLatestContent on an unready TextFileWatcher");
    }
    return this.state.localText.sliceString(0);
  }
  getIsReady() {
    if (this.isDisposed) {
      throw new Error("Cannot get isReady of a disposed TextFileWatcher");
    }
    return Boolean(this.state);
  }
  async handleReady({
    writeChange,
    initialContent
  }) {
    if (this.isDisposed) {
      return;
    }
    const content = Text.of((await initialContent).split("\n"));
    this.state = {
      requestWriteChange: writeChange,
      localText: content,
      remoteText: content,
      unconfirmedChanges: /* @__PURE__ */ new Set()
    };
    this.listeners.onReady();
  }
  handleChange({ changes: changeJSON }) {
    if (this.isDisposed) {
      return;
    }
    if (!this.state) {
      throw new Error("unexpected handleOnChange called before handleOnReady");
    }
    let changes = ChangeSet.fromJSON(changeJSON);
    this.state.remoteText = changes.apply(this.state.remoteText);
    for (const unconfirmed of this.state.unconfirmedChanges) {
      const unconfirmedUpdated = unconfirmed.changes.map(changes);
      changes = changes.map(unconfirmed.changes, true);
      unconfirmed.changes = unconfirmedUpdated;
    }
    this.state.localText = changes.apply(this.state.localText);
    this.listeners.onChange({
      changes: changeSetToSimpleTextChange(changes),
      latestContent: this.getLatestContent()
    });
  }
  async enqueueChangeSet(changes) {
    if (this.isDisposed) {
      throw new Error("Wrote change on a disposed TextFileWatcher");
    }
    if (!this.state) {
      throw new Error("Tried to write changes before ready");
    }
    const ref = { changes };
    this.state.unconfirmedChanges.add(ref);
    await this.state.requestWriteChange(
      changeSetToSimpleTextChange(ref.changes)
    );
    this.state.unconfirmedChanges.delete(ref);
    this.state.remoteText = ref.changes.apply(this.state.remoteText);
  }
};
var FileWatcherManager = class {
  files;
  constructor() {
    this.files = /* @__PURE__ */ new Map();
  }
  watch(path, listeners) {
    if (this.files.has(path)) {
      this.watchExisting(path, listeners);
    } else {
      this.watchNew(path, listeners);
    }
    return () => {
      const file = this.files.get(path);
      if (!file) {
        return;
      }
      file.listeners.delete(listeners);
      if (file.listeners.size === 0) {
        this.dispose(path);
      }
    };
  }
  dispose(path) {
    const file = this.files.get(path);
    if (!file) {
      return;
    }
    file.watcher.dispose();
    this.files.delete(path);
  }
  watchNew(path, listeners) {
    const watcher = new TextFileWatcher(path, {
      onReady: () => {
        this.handleReady(path);
      },
      onChange: (changeEvent) => {
        this.handleChange(path, changeEvent);
      },
      onMoveOrDelete: (event) => {
        this.handleMoveOrDelete(path, event);
      },
      onError: (error2) => {
        this.handleError(path, error2);
      }
    });
    this.files.set(path, {
      listeners: /* @__PURE__ */ new Set([listeners]),
      watcher
    });
  }
  watchExisting(path, listeners) {
    const file = this.files.get(path);
    if (!file) {
      throw new Error("file is not watched");
    }
    file.listeners.add(listeners);
  }
  handleChange(path, changeEvent) {
    const file = this.files.get(path);
    if (!file) {
      throw new Error("Unexpected change on a non-watched file");
    }
    if (!file.watcher.getIsReady()) {
      throw new Error("Unexpected change on a non-ready file");
    }
    for (const { onChange } of file.listeners) {
      if (!onChange) {
        continue;
      }
      onChange(changeEvent);
    }
  }
  handleReady(path) {
    const file = this.files.get(path);
    if (!file) {
      throw new Error("Unexpected change on a non-watched file");
    }
    if (!file.watcher.getIsReady()) {
      throw new Error("Got ready on a non-ready file :/");
    }
    const initialContent = file.watcher.getLatestContent();
    for (const { onReady, onChange } of file.listeners) {
      onReady({
        initialContent,
        getLatestContent: () => file.watcher.getLatestContent(),
        writeChange: (changes) => {
          file.watcher.writeChange(changes);
          for (const { onChange: otherOnChange } of file.listeners) {
            if (onChange === otherOnChange) {
              continue;
            }
            if (!otherOnChange) {
              continue;
            }
            otherOnChange({
              changes: Array.isArray(changes) ? changes : [changes],
              latestContent: file.watcher.getLatestContent()
            });
          }
        }
      });
    }
  }
  handleError(path, error2) {
    const file = this.files.get(path);
    if (!file) {
      throw new Error("Unexpected error on a non-watched file");
    }
    for (const { onError } of file.listeners) {
      if (!onError) {
        continue;
      }
      onError(error2);
    }
    this.dispose(path);
  }
  handleMoveOrDelete(path, event) {
    const file = this.files.get(path);
    if (!file) {
      throw new Error("Unexpected move or delete event on a non-watched file");
    }
    for (const { onMoveOrDelete } of file.listeners) {
      if (!onMoveOrDelete) {
        continue;
      }
      onMoveOrDelete(event);
    }
    this.dispose(path);
  }
};
var fileWatcherManager = new FileWatcherManager();

// src/api/fs/index.ts
async function readFile(path, encoding = "utf8") {
  return extensionPort.readFile(path, encoding);
}
async function writeFile(path, content) {
  return extensionPort.writeFile(path, content);
}
async function readDir(path) {
  return extensionPort.readDir(path);
}
async function createDir(path) {
  return extensionPort.createDir(path);
}
async function deleteFile(path) {
  return extensionPort.deleteFile(path);
}
async function deleteDir(path) {
  return extensionPort.deleteDir(path);
}
async function move(path, to) {
  return extensionPort.move(path, to);
}
async function copyFile(path, to) {
  return extensionPort.copyFile(path, to);
}
async function watchFile(path, listeners, encoding = "binary") {
  return extensionPort.watchFile(
    path,
    proxy2({
      onMoveOrDelete: () => {
      },
      onError: () => {
      },
      ...listeners
    }),
    encoding
  );
}
async function watchDir(path, listeners) {
  return extensionPort.watchDir(
    path,
    proxy2({
      onMoveOrDelete: () => {
      },
      ...listeners
    })
  );
}
function watchTextFile(path, listeners) {
  return fileWatcherManager.watch(path, listeners);
}

// src/api/replDb.ts
var replDb_exports = {};
__export(replDb_exports, {
  del: () => del,
  get: () => get,
  list: () => list,
  set: () => set
});
async function set(args) {
  return extensionPort.setReplDbValue(args.key, args.value);
}
async function get(args) {
  return extensionPort.getReplDbValue(args.key);
}
async function list(args = {}) {
  return extensionPort.listReplDbKeys(args?.prefix || "");
}
async function del(args) {
  return extensionPort.deleteReplDbKey(args.key);
}

// src/api/me.ts
var me_exports = {};
__export(me_exports, {
  filePath: () => filePath
});
function filePath() {
  return extensionPort.filePath;
}

// src/api/theme.ts
var theme_exports = {};
__export(theme_exports, {
  getCurrentTheme: () => getCurrentTheme,
  getCurrentThemeValues: () => getCurrentThemeValues,
  onThemeChange: () => onThemeChange,
  onThemeChangeValues: () => onThemeChangeValues
});
import { proxy as proxy3 } from "comlink";
async function getCurrentTheme() {
  return await extensionPort.getCurrentTheme();
}
async function getCurrentThemeValues() {
  return await extensionPort.getCurrentThemeValues();
}
async function onThemeChange(callback) {
  return await extensionPort.onThemeChange(proxy3(callback));
}
async function onThemeChangeValues(callback) {
  return await extensionPort.onThemeChangeValues(proxy3(callback));
}

// src/api/messages.ts
var messages_exports = {};
__export(messages_exports, {
  hideAllMessages: () => hideAllMessages,
  hideMessage: () => hideMessage,
  showConfirm: () => showConfirm,
  showError: () => showError,
  showNotice: () => showNotice,
  showWarning: () => showWarning
});
var showConfirm = async (str, length = 4e3) => {
  if (typeof str !== "string") {
    throw new Error("Messages must be strings");
  }
  return extensionPort.showConfirm(str, length);
};
var showError = async (str, length = 4e3) => {
  if (typeof str !== "string") {
    throw new Error("Messages must be strings");
  }
  return extensionPort.showError(str, length);
};
var showNotice = async (str, length = 4e3) => {
  if (typeof str !== "string") {
    throw new Error("Messages must be strings");
  }
  return extensionPort.showNotice(str, length);
};
var showWarning = async (str, length = 4e3) => {
  if (typeof str !== "string") {
    throw new Error("Messages must be strings");
  }
  return extensionPort.showWarning(str, length);
};
var hideMessage = async (id) => {
  return extensionPort.hideMessage(id);
};
var hideAllMessages = async () => {
  return extensionPort.hideAllMessages();
};

// src/api/data.ts
var data_exports = {};
__export(data_exports, {
  currentRepl: () => currentRepl,
  currentUser: () => currentUser,
  replById: () => replById,
  replByUrl: () => replByUrl,
  userById: () => userById,
  userByUsername: () => userByUsername
});
async function currentUser(args = {}) {
  return await extensionPort.currentUser(args);
}
async function userById(args) {
  if (typeof args.id !== "number") {
    throw new Error(
      `Query parameter "id" must be a number.  Found type ${typeof args.id} instead.`
    );
  }
  return await extensionPort.userById(args);
}
async function userByUsername(args) {
  if (typeof args.username !== "string") {
    throw new Error(
      `Query parameter "username" must be a string.  Found type ${typeof args.username} instead.`
    );
  }
  return await extensionPort.userByUsername(args);
}
async function currentRepl(args = {}) {
  return await extensionPort.currentRepl(args);
}
async function replById(args) {
  if (typeof args.id !== "string") {
    throw new Error(
      `Query parameter "id" must be a string.  Found type ${typeof args.id} instead.`
    );
  }
  return await extensionPort.replById(args);
}
async function replByUrl(args) {
  if (typeof args.url !== "string") {
    throw new Error(
      `Query parameter "url" must be a string.  Found type ${typeof args.url} instead.`
    );
  }
  return await extensionPort.replByUrl(args);
}

// src/api/session.ts
var session_exports = {};
__export(session_exports, {
  getActiveFile: () => getActiveFile,
  onActiveFileChange: () => onActiveFileChange
});
function onActiveFileChange(listener) {
  let dispose = () => {
    console.log("disposing existing watcher");
  };
  extensionPort.watchActiveFile(proxy2(listener)).then((d) => {
    dispose = d;
  });
  return () => {
    dispose();
  };
}
async function getActiveFile() {
  return await extensionPort.getActiveFile();
}

// src/api/experimental/index.ts
var experimental_exports = {};
__export(experimental_exports, {
  auth: () => auth_exports,
  editor: () => editor_exports
});

// src/api/experimental/auth.ts
var auth_exports = {};
__export(auth_exports, {
  authenticate: () => authenticate,
  getAuthToken: () => getAuthToken,
  verifyAuthToken: () => verifyAuthToken
});
import * as jose from "jose";

// src/polyfills/ed25519.ts
import { ed25519 as ed } from "@noble/curves/ed25519";
import { bytesToHex } from "@noble/curves/abstract/utils";
import * as asn1 from "@root/asn1";
import { toBase64Url as b64encode, toBuffer as b64decode } from "b64u-lite";
var C = {
  wicgAlgorithm: "Ed25519",
  nodeAlgorithm: "NODE-ED25519",
  nodeNamedCurve: "NODE-ED25519",
  kty: "OKP",
  crv: "Ed25519",
  oid: "2B6570".toLowerCase()
};
function isEd25519Algorithm(a) {
  return a === C.wicgAlgorithm || a === C.nodeAlgorithm || a.name === C.wicgAlgorithm || a.name === C.nodeAlgorithm && a.namedCurve === C.nodeNamedCurve;
}
var Ed25519Algorithm = {
  name: C.wicgAlgorithm
};
function asUint8Array(b) {
  if (b instanceof Uint8Array) {
    return b;
  }
  if (b instanceof ArrayBuffer) {
    return new Uint8Array(b);
  }
  return new Uint8Array(b.buffer, b.byteOffset, b.byteLength);
}
function asArrayBuffer(b) {
  if (b.byteLength === b.buffer.byteLength) {
    return b.buffer;
  }
  return b.buffer.slice(b.byteOffset, b.byteLength);
}
var slot = "8d9df0f7-1363-4d2c-8152-ce4ed78f27d8";
var Ponyfill = class {
  constructor(super_) {
    this.super_ = super_;
    this.orig_ = {};
    for (const method of [
      "generateKey",
      "exportKey",
      "importKey",
      "encrypt",
      "decrypt",
      "wrapKey",
      "unwrapKey",
      "deriveBits",
      "deriveKey",
      "sign",
      "verify",
      "digest"
    ]) {
      if (this[method]) {
        this.orig_[method] = super_[method];
      } else {
        this[method] = super_[method].bind(super_);
      }
    }
  }
  orig_;
  async generateKey(algorithm, extractable, keyUsages) {
    if (isEd25519Algorithm(algorithm)) {
      const pvt = ed.utils.randomPrivateKey();
      const pub = await ed.getPublicKey(pvt);
      const usages = Array.from(keyUsages);
      const privateKey = {
        algorithm,
        extractable,
        type: "private",
        usages,
        [slot]: pvt
      };
      const publicKey = {
        algorithm,
        extractable: true,
        type: "public",
        usages,
        [slot]: pub
      };
      return { privateKey, publicKey };
    }
    return this.orig_.generateKey.apply(this.super_, arguments);
  }
  async exportKey(format, key) {
    if (isEd25519Algorithm(key.algorithm) && key.extractable) {
      const raw = key[slot];
      switch (format) {
        case "jwk": {
          const jwk = {
            kty: C.kty,
            crv: C.crv
          };
          if (key.type === "public") {
            jwk.x = b64encode(raw);
          } else {
            jwk.d = b64encode(raw);
            jwk.x = b64encode(await ed.getPublicKey(raw));
          }
          return jwk;
        }
        case "spki": {
          return asArrayBuffer(
            asn1.pack([
              "30",
              [
                ["30", [["06", "2B6570"]]],
                ["03", raw]
              ]
            ])
          );
        }
      }
    }
    return this.orig_.exportKey.apply(this.super_, arguments);
  }
  async importKey(format, keyData, algorithm, extractable, keyUsages) {
    if (isEd25519Algorithm(algorithm)) {
      const usages = Array.from(keyUsages);
      switch (format) {
        case "jwk": {
          const jwk = keyData;
          if (jwk.kty !== C.kty || jwk.crv !== C.crv || !jwk.x) {
            break;
          }
          const key = {
            algorithm,
            extractable,
            type: jwk.d ? "private" : "public",
            usages,
            [slot]: b64decode(jwk.d ?? jwk.x)
          };
          return key;
        }
        case "spki": {
          const der = asn1.parseVerbose(asUint8Array(keyData));
          const algo = der.children?.[0]?.children?.[0]?.value;
          const raw = der.children?.[1]?.value;
          if (!(algo instanceof Uint8Array) || bytesToHex(algo) !== C.oid || !(raw instanceof Uint8Array)) {
            break;
          }
          const key = {
            algorithm,
            extractable: true,
            type: "public",
            usages,
            [slot]: raw
          };
          return key;
        }
      }
    }
    return this.orig_.importKey.apply(this.super_, arguments);
  }
  async sign(algorithm, key, data) {
    if (isEd25519Algorithm(algorithm) && isEd25519Algorithm(key.algorithm) && key.type === "private" && key.usages.includes("sign")) {
      return asArrayBuffer(
        await ed.sign(asUint8Array(data), key[slot])
      );
    }
    return this.orig_.sign.apply(this.super_, arguments);
  }
  async verify(algorithm, key, signature, data) {
    if (isEd25519Algorithm(algorithm) && isEd25519Algorithm(key.algorithm) && key.type === "public" && key.usages.includes("verify")) {
      const s = asUint8Array(signature);
      const m = asUint8Array(data);
      const p = key[slot];
      return ed.verify(s, m, p);
    }
    return this.orig_.verify.apply(this.super_, arguments);
  }
};
function ponyfillEd25519(subtle = crypto.subtle) {
  if (!subtle) {
    console.warn(`polyfill ed25519: crypto.subtle is not available`);
    return null;
  }
  return new Ponyfill(subtle);
}
function polyfillEd25519() {
  const ponyfill = ponyfillEd25519();
  if (!ponyfill) {
    return false;
  }
  Object.defineProperty(globalThis.crypto, "subtle", {
    value: ponyfill,
    configurable: true
  });
  return true;
}

// src/api/experimental/auth.ts
var success = typeof window !== "undefined" ? polyfillEd25519() : false;
if (!success) {
  console.warn(
    "Failed to polyfill ed25519: crypto.subtle is not available in the environment. This will cause issues with the auth API."
  );
}
async function getAuthToken() {
  return extensionPort.experimental.auth.getAuthToken();
}
async function verifyAuthToken(token) {
  const tokenHeaders = jose.decodeProtectedHeader(token);
  if (tokenHeaders.typ !== "JWT") {
    throw new Error("Expected typ: JWT");
  }
  if (tokenHeaders.alg !== "EdDSA") {
    throw new Error("Expected alg: EdDSA");
  }
  if (!tokenHeaders.kid) {
    throw new Error("Expected `kid` to be defined");
  }
  const res = await fetch(
    `https://replit.com/data/extensions/publicKey/${tokenHeaders.kid}`
  );
  const { ok, value: publicKey } = await res.json();
  if (!ok) {
    throw new Error("Extension Auth: Failed to fetch public key");
  }
  try {
    const importedPublicKey = await jose.importSPKI(publicKey, "EdDSA");
    const decodedToken = await jose.jwtVerify(token, importedPublicKey);
    return decodedToken;
  } catch (e) {
    throw new Error("Extension Auth: Failed to verify token");
  }
}
async function authenticate() {
  const token = await getAuthToken();
  const decodedToken = await verifyAuthToken(token);
  if (typeof decodedToken.payload.userId !== "number" || typeof decodedToken.payload.installationId !== "string" || typeof decodedToken.payload.extensionId !== "string") {
    throw new Error("Failed to authenticate");
  }
  return {
    user: {
      id: decodedToken.payload.userId
    },
    installation: {
      id: decodedToken.payload.installationId,
      extensionId: decodedToken.payload.extensionId
    }
  };
}

// src/api/experimental/editor.ts
var editor_exports = {};
__export(editor_exports, {
  getPreferences: () => getPreferences
});
async function getPreferences() {
  return await extensionPort.experimental.editor.getPreferences();
}

// src/api/internal/index.ts
var internal_exports = {};

// src/api/exec.ts
var exec_exports = {};
__export(exec_exports, {
  exec: () => exec,
  spawn: () => spawn
});
function spawn(options) {
  let execResult = extensionPort.exec(
    proxy2({
      args: options.args,
      env: options.env || {},
      splitStderr: options.splitStderr ?? false,
      onOutput: (output) => {
        if (options.splitStderr) {
          options.onStdOut?.(output);
        } else {
          options.onOutput?.(output);
        }
      },
      onStdErr: (stderr) => {
        if (options.splitStderr) {
          options.onStdErr?.(stderr);
        } else {
          options.onOutput?.(stderr);
        }
      },
      onError: (err) => {
        throw err;
      }
    })
  );
  let dispose = async () => {
    (await execResult).dispose();
  };
  const resultPromise = new Promise(async (resolve) => {
    const { exitCode, error: error2 } = await (await execResult).promise;
    resolve({
      error: error2,
      exitCode: exitCode ?? 0
    });
  });
  return {
    resultPromise,
    dispose
  };
}
async function exec(command, options = {}) {
  let output = "";
  const { resultPromise } = spawn({
    args: ["bash", "-c", command],
    env: options.env ?? {},
    splitStderr: false,
    onOutput: (newOutput) => {
      output += newOutput;
    }
  });
  const result = await resultPromise;
  if (result.error) {
    throw new Error(result.error);
  }
  return {
    output,
    exitCode: result.exitCode
  };
}

// src/api/debug.ts
var debug_exports = {};
__export(debug_exports, {
  error: () => error,
  info: () => info,
  log: () => log,
  warn: () => warn
});
async function info(message, data) {
  if (typeof message !== "string") {
    throw new Error("Message must be a string");
  }
  return await extensionPort.debug.info(message, data);
}
async function warn(message, data) {
  if (typeof message !== "string") {
    throw new Error("Message must be a string");
  }
  return await extensionPort.debug.warn(message, data);
}
async function error(message, data) {
  if (typeof message !== "string") {
    throw new Error("Message must be a string");
  }
  return await extensionPort.debug.error(message, data);
}
var log = info;

// package.json
var version = "1.7.2";

// src/index.ts
function promiseWithTimeout(promise, timeout) {
  return Promise.race([
    promise,
    new Promise(
      (_resolve, reject) => setTimeout(() => reject(new Error("timeout")), timeout)
    )
  ]);
}
async function windowIsReady() {
  return new Promise((resolve) => {
    if (document.readyState === "complete") {
      resolve();
      return;
    }
    const loadHandler = () => {
      resolve();
      window.removeEventListener("load", loadHandler);
    };
    window.addEventListener("load", loadHandler);
  });
}
function patchConsole() {
  const originalLog = console.log;
  const originalWarn = console.warn;
  const originalError = console.error;
  const originalInfo = console.info;
  console.log = (...args) => {
    originalLog(...args);
    log(args[0], { args: args.slice(1) });
  };
  console.warn = (...args) => {
    originalWarn(...args);
    warn(args[0], { args: args.slice(1) });
  };
  console.error = (...args) => {
    originalError(...args);
    error(args[0], { args: args.slice(1) });
  };
  console.info = (...args) => {
    originalInfo(...args);
    info(args[0], { args: args.slice(1) });
  };
}
async function init(args) {
  if (extensionPort === null) {
    throw new Error("Extension must be initialized in a browser context");
  }
  const onExtensionClick = () => {
    extensionPort.activatePane();
  };
  const windDown = () => {
    window.document.removeEventListener("click", onExtensionClick);
  };
  try {
    if (window) {
      await windowIsReady();
    }
    await promiseWithTimeout(
      extensionPort.handshake({
        clientName: "@replit/extensions",
        clientVersion: version
      }),
      args?.timeout || 2e3
    );
    patchConsole();
    setHandshakeStatus("ready" /* Ready */);
    if (window) {
      window.document.addEventListener("click", onExtensionClick);
    }
  } catch (e) {
    setHandshakeStatus("error" /* Error */);
    console.error(e);
    windDown();
    throw e;
  }
  return {
    dispose: windDown,
    status: getHandshakeStatus()
  };
}
export {
  ChangeEventType,
  ColorScheme,
  FsNodeType,
  HandshakeStatus,
  UserSocialType,
  copyFile,
  createDir,
  data_exports as data,
  debug_exports as debug,
  deleteDir,
  deleteFile,
  exec_exports as exec,
  experimental_exports as experimental,
  extensionPort,
  fs_exports as fs,
  init,
  internal_exports as internal,
  me_exports as me,
  messages_exports as messages,
  move,
  proxy2 as proxy,
  readDir,
  readFile,
  replDb_exports as replDb,
  session_exports as session,
  theme_exports as themes,
  version,
  watchDir,
  watchFile,
  watchTextFile,
  writeFile
};
//# sourceMappingURL=index.js.map